<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Functions frequently used</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<!-- Override default jQuery -->
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Language learning lab</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="usefulFunctions-explained.html">Functions</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Functions frequently used</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#addbf_ranges" id="toc-addbf_ranges">addBf_ranges</a></li>
<li><a href="#addbf_ranges3"
id="toc-addbf_ranges3">addBf_ranges3</a></li>
<li><a href="#add_p_tails_match_bf"
id="toc-add_p_tails_match_bf">add_p_tails_match_Bf</a></li>
<li><a href="#adjust_intercept_model"
id="toc-adjust_intercept_model">adjust_intercept_model</a></li>
<li><a href="#bayesfactor-updated"
id="toc-bayesfactor-updated">BayesFactor <em>updated</em></a></li>
<li><a href="#bfclassify" id="toc-bfclassify">BfClassify</a></li>
<li><a href="#bf_model" id="toc-bf_model">Bf_model</a></li>
<li><a href="#bf_powercalc" id="toc-bf_powercalc">Bf_powercalc</a></li>
<li><a href="#bf_range" id="toc-bf_range">Bf_range</a></li>
<li><a href="#bf_set" id="toc-bf_set">Bf_set</a></li>
<li><a href="#confidence-interval-calculators-95-ci"
id="toc-confidence-interval-calculators-95-ci">confidence interval
calculators (95% CI)</a>
<ul>
<li><a href="#example" id="toc-example">Example:</a></li>
</ul></li>
<li><a href="#deleterandomrows"
id="toc-deleterandomrows">deleteRandomRows</a></li>
<li><a href="#download_from_gorilla"
id="toc-download_from_gorilla">download_from_Gorilla</a>
<ul>
<li><a href="#example-1" id="toc-example-1">Example:</a></li>
</ul></li>
<li><a href="#filter2" id="toc-filter2">filter2</a></li>
<li><a href="#generate_bin" id="toc-generate_bin">generate_bin</a></li>
<li><a href="#getmode" id="toc-getmode">getmode</a></li>
<li><a href="#get_coeffs" id="toc-get_coeffs">get_coeffs</a></li>
<li><a href="#get_coeffs2" id="toc-get_coeffs2">get_coeffs2</a></li>
<li><a href="#inverse_log_odd"
id="toc-inverse_log_odd">inverse_log_odd</a></li>
<li><a href="#lizcenter" id="toc-lizcenter">lizCenter</a></li>
<li><a href="#lizcenter2" id="toc-lizcenter2">lizCenter2</a></li>
<li><a href="#lizcontrasts" id="toc-lizcontrasts">lizContrasts</a></li>
<li><a href="#lizcontrasts4"
id="toc-lizcontrasts4">lizContrasts4</a></li>
<li><a href="#loadfunctionsgithub"
id="toc-loadfunctionsgithub">loadFunctionsGithub</a></li>
<li><a href="#logodds" id="toc-logodds">logodds</a></li>
<li><a href="#mycenter" id="toc-mycenter">myCenter</a></li>
<li><a href="#normdatawithin"
id="toc-normdatawithin">normDataWithin</a></li>
<li><a href="#num.decimals" id="toc-num.decimals">num.decimals</a></li>
<li><a href="#percentage" id="toc-percentage">percentage</a></li>
<li><a href="#round_df" id="toc-round_df">round_df</a></li>
<li><a href="#selectcenter" id="toc-selectcenter">selectCenter</a></li>
<li><a href="#stat_string" id="toc-stat_string">stat_string</a></li>
<li><a href="#stat_string2" id="toc-stat_string2">stat_string2</a></li>
<li><a href="#summaryse" id="toc-summaryse">summarySE</a></li>
<li><a href="#summarysewithin"
id="toc-summarysewithin">summarySEwithin</a></li>
<li><a href="#summarysewithin2"
id="toc-summarysewithin2">summarySEwithin2</a></li>
</ul>
</div>

<p>This is an R Markdown document explaining all the functions used by
the language and learning lab. The functions are stored into the <a
href="https://github.com/n400peanuts/languagelearninglab/tree/master/tools">tools</a>
folder.</p>
<div id="addbf_ranges" class="section level2">
<h2>addBf_ranges</h2>
<p>This function takes as its input a dataframe which is the output of
the BF_set function. This will have a set of betas, standard errors and
sd-theory. The function adds and additional column to this table which
shows the range of values over which BF’s meet the criteria of (i)
strong evdience for null (BF&lt; 1/10); substantial evidence for null
(BF&lt; 1/3); ambiguous (3 &gt; BF &gt;1/3 ); substantial evidence H1
(BF &gt;= 10).</p>
<pre class="r"><code>addBf_ranges &lt;-function(Bf_df, sdtheoryrange)
{
  
  BFranges = vector()  
  for (b in 1:dim(Bf_df)[1]){
    range = Bf_range(sd=as.numeric(as.character(Bf_df$SE[b])), obtained=as.numeric(as.character(Bf_df$&#39;Mean difference&#39;[b])), meanoftheory=0, sdtheoryrange=sdtheoryrange)
    
    from_table = vector()
    to_table = vector()
    cat = vector()
    category_table = vector()
    
    for(i in 1:dim(range)[1]) {       # go through each value in the range and categorize it
      
      #categorize current BF 
      if (range[i,2] &lt;= (1/3)) { 
        cat[i] = &quot;H0&quot;      ## below or equal to 1/3
      } else if (range[i,2] &lt; 3) { ## NOT below or equal to 1/3, IS below 3 
        cat[i] = &quot;ambig&quot;
      } else {                ## NOT below or equal to 1/3, NOT below 3
        cat[i] = &quot;substH1&quot;
      }
      
      # adjust the table
      j = length(category_table) 
      
      if (i==1){                      # first one
        category_table[j+1] = cat[i]   
        from_table[j+1] = range[i,1]
        
      } else if (cat[i] != cat[i-1]) { # NOT the first one, IS one where need to start new range 
        to_table[j] = range[i-1,1]
        category_table[j+1] = cat[i]
        from_table[j+1] = range[i,1]
      } 
      
      if (i==dim(range)[1]){        # if its the last one, finish off the table
        to_table[j] = range[i,1]
      }
    }
    
    # go through the little table and turn it int a string of ranges  
    string = &quot;&quot;
    for(i in 1: length(category_table)){
      string = paste(string, category_table[i],&quot;:&quot;, round(from_table[i],3),&quot;-&quot;, round(to_table[i],3))
    }
    
    BFranges[b] = string
  }
  out = cbind(Bf_df, BFranges)
  return(out)
}</code></pre>
</div>
<div id="addbf_ranges3" class="section level2">
<h2>addBf_ranges3</h2>
<p>Author: Elizabeth Wonnacott</p>
<p>Similar to addBf_ranges2 except that it works out ranges by working
down/up from the given sd_theory value in increments given by stepsizes
up to maximum given by maxs. Stepsizes/maxs can either be a single value
used across all the coefficients or can be a vector of values (one per
row - size must match )</p>
<pre class="r"><code>addBf_ranges3 = function(Bf_df, stepsizes, maxs, method = &quot;old&quot;) {
  
  if(method==&quot;old&quot;){  
    RRminV = vector()
    RRmaxV = vector()
    for (b in 1:dim(Bf_df)[1]){
      
      if (length(stepsizes)==1){stepsize = stepsizes} else {stepsize = stepsizes[b]}
      if (length(maxs)==1){max = maxs} else {max = maxs[b]}
      
      
      Ndp = num.decimals(stepsize)
      BF = as.numeric(as.character(Bf_df$Bf[b]))  
      BType= BfClassify(BF) 
      sdtheory = as.numeric(as.character(Bf_df$sdtheory[b]))  
      sd = as.numeric(as.character(Bf_df$std.Error[b]))
      obtained = as.numeric(as.character(Bf_df$estimate[b]))
      tail = as.numeric(as.character(Bf_df$BFtail[b]))
      
      # get the max RRmax 
      RRmax = &quot;&quot;
      lastsdtheory = sdtheory
      newsdtheory = &quot;&quot;
      while(newsdtheory&lt;= max){
        newsdtheory = lastsdtheory + stepsize
        newBF = Bf(sd=sd, obtained=obtained, uniform = NULL, meanoftheory=0,sdtheory=newsdtheory, tail=tail)$BayesFactor
        
        if (BfClassify(newBF)!= BType) {
          RRmax = format(round(lastsdtheory, Ndp))
          break }
        lastsdtheory = newsdtheory
      }
      
      if(RRmax == &quot;&quot; &amp; BType == &quot;h0&quot;) {RRmax = &quot;inf&quot;}  
      if(RRmax == &quot;&quot; &amp; BType == &quot;h1&quot;) {RRmax = paste(&quot;&gt;&quot;, max, sep=&quot;&quot;)}  
      if(RRmax == &quot;&quot; &amp; BType == &quot;ambig&quot;) {RRmax = paste(&quot;&gt;&quot;, max, sep=&quot;&quot;)}  
      
      # get the min RRmin 
      RRmin = &quot;&quot;
      lastsdtheory = sdtheory
      newsdtheory = lastsdtheory - stepsize
      
      while(newsdtheory &gt; 0){
        newBF = Bf(sd=sd, obtained=obtained, uniform = NULL, meanoftheory=0,sdtheory=newsdtheory, tail=tail)$BayesFactor
        
        if (BfClassify(newBF)!= BType) {
          RRmin = format(round(lastsdtheory, Ndp))
          break }
        lastsdtheory = newsdtheory
        newsdtheory = lastsdtheory-stepsize
      }
      
      if(RRmin== &quot;&quot; &amp; BType == &quot;ambig&quot;) {RRmin = 0}  
      if(RRmin== &quot;&quot; &amp; BType == &quot;h1&quot;) {RRmin = paste(&quot; 0&lt; &amp; &lt;&quot;, format(round(lastsdtheory,  Ndp), nsmall=Ndp), sep=&quot;&quot;)} 
      if(RRmin== &quot;&quot; &amp; BType == &quot;h0&quot;) {RRmin = paste(&quot; 0&lt; &amp; &lt;&quot;, format(round(lastsdtheory,  Ndp), nsmall=Ndp), sep=&quot;&quot;)}  
      
      RRminV[b] = RRmin
      RRmaxV[b] = RRmax
      
    }
    out = cbind(Bf_df, RRminV, RRmaxV)
    
    colnames(out)[10:11]= c(&quot;RRmin&quot;,&quot;RRmax&quot;)
    
    return(out)
  }
  if(method==&quot;new&quot;){  
    RRminV = vector()
    RRmaxV = vector()
    for (b in 1:dim(Bf_df)[1]){
      
      
      if (length(stepsizes)==1){stepsize = stepsizes} else {stepsize = stepsizes[b]}
      if (length(maxs)==1){max = maxs} else {max = maxs[b]}
      
      
      Ndp = num.decimals(stepsize)
      BF = as.numeric(as.character(Bf_df$Bf[b]))  
      BType= BfClassify(BF) 
      sdtheory = as.numeric(as.character(Bf_df$sdtheory[b]))  
      sd = as.numeric(as.character(Bf_df$std.Error[b]))
      obtained = as.numeric(as.character(Bf_df$estimate[b]))
      tail = as.numeric(as.character(Bf_df$BFtail[b]))
      
      # get the max RRmax 
      RRmax = &quot;&quot;
      lastsdtheory = sdtheory
      newsdtheory = &quot;&quot;
      while(newsdtheory&lt;= max){
        newsdtheory = lastsdtheory + stepsize
        if(colnames(Bf_df)[4]==&quot;t&quot;){
          dfdata=as.numeric(as.character(Bf_df$df[b]))
          newBF = Bf(sd=sd, obtained=obtained, dfdata=dfdata, likelihood = c(&quot;t&quot;), modeloftheory= c(&quot;normal&quot;),modeoftheory=0,scaleoftheory=newsdtheory, tail=tail, method=&quot;new&quot;)
        }
        if(colnames(Bf_df)[4]==&quot;z&quot;){
          dfdata=as.numeric(as.character(Bf_df$df[b]))
          newBF = Bf(sd=sd, obtained=obtained,  likelihood = c(&quot;normal&quot;), modeloftheory= c(&quot;normal&quot;),modeoftheory=0,scaleoftheory=newsdtheory, tail=tail, method=&quot;new&quot;)
        }
        
        if (BfClassify(newBF)!= BType) {
          RRmax = format(round(lastsdtheory, Ndp))
          break }
        lastsdtheory = newsdtheory
      }
      
      if(RRmax == &quot;&quot; &amp; BType == &quot;h0&quot;) {RRmax = &quot;inf&quot;}  
      if(RRmax == &quot;&quot; &amp; BType == &quot;h1&quot;) {RRmax = paste(&quot;&gt;&quot;, max, sep=&quot;&quot;)}  
      if(RRmax == &quot;&quot; &amp; BType == &quot;ambig&quot;) {RRmax = paste(&quot;&gt;&quot;, max, sep=&quot;&quot;)}  
      
      # get the min RRmin 
      RRmin = &quot;&quot;
      lastsdtheory = sdtheory
      newsdtheory = lastsdtheory - stepsize
      
      while(newsdtheory &gt; 0){
        if(colnames(Bf_df)[4]==&quot;t&quot;){
          dfdata=as.numeric(as.character(Bf_df$df[b]))
          newBF = Bf(sd=sd, obtained=obtained, dfdata=dfdata, likelihood = c(&quot;t&quot;), modeloftheory= c(&quot;normal&quot;),modeoftheory=0,scaleoftheory=newsdtheory, tail=tail, method=&quot;new&quot;)
        }
        
        
        if(colnames(Bf_df)[4]==&quot;z&quot;){
          dfdata=as.numeric(as.character(Bf_df$df[b]))
          newBF = Bf(sd=sd, obtained=obtained,  likelihood = c(&quot;normal&quot;), modeloftheory= c(&quot;normal&quot;),modeoftheory=0,scaleoftheory=newsdtheory, tail=tail, method=&quot;new&quot;)
        }
        
        if (is.nan(newBF)) {
          RRmin = format(round(lastsdtheory, Ndp))
          break }
        if (BfClassify(newBF)!= BType) {
          RRmin = format(round(lastsdtheory, Ndp))
          break }
        lastsdtheory = newsdtheory
        newsdtheory = lastsdtheory-stepsize
      }
      
      if(RRmin== &quot;&quot; &amp; BType == &quot;ambig&quot;) {RRmin = 0}  
      if(RRmin== &quot;&quot; &amp; BType == &quot;h1&quot;) {RRmin = paste(&quot; 0&lt; &amp; &lt;&quot;, format(round(lastsdtheory,  Ndp), nsmall=Ndp), sep=&quot;&quot;)} 
      if(RRmin== &quot;&quot; &amp; BType == &quot;h0&quot;) {RRmin = paste(&quot; 0&lt; &amp; &lt;&quot;, format(round(lastsdtheory,  Ndp), nsmall=Ndp), sep=&quot;&quot;)}  
      
      RRminV[b] = RRmin
      RRmaxV[b] = RRmax
      
    }
    out = cbind(Bf_df, RRminV, RRmaxV)
    
    colnames(out)[10:11]= c(&quot;RRmin&quot;, &quot;RRmax&quot;)
    
    return(out)
  }
}  </code></pre>
</div>
<div id="add_p_tails_match_bf" class="section level2">
<h2>add_p_tails_match_Bf</h2>
<p>This function takes a table output by the Bfs_ranges function (or the
BF_model function and for any rows where the tails are set as 1 adjusts
the pvalues to be one-tailed. This means that the tails for BFs and p
values are consistent)</p>
<pre class="r"><code>add_p_tails_match_Bf &lt;- function(Bfs.table) {
  Bfs.table$p_tails_match_Bf = Bfs.table$p
  Bfs.table$p_tails_match_Bf[Bfs.table$BFtail == 1 &amp;
                               Bfs.table$z &gt; 0] = Bfs.table$p[Bfs.table$BFtail == 1 &amp;
                                                                Bfs.table$z &gt; 0] / 2
  Bfs.table$p_tails_match_Bf[Bfs.table$BFtail == 1 &amp;
                               Bfs.table$z &lt; 0] = 1 - Bfs.table$p[Bfs.table$BFtail == 1 &amp;
                                                                    Bfs.table$z &lt; 0] / 2
  Bfs.table$p_tails_match_Bf[Bfs.table$BFtail == 1 &amp;
                               Bfs.table$t &gt; 0] = Bfs.table$p[Bfs.table$BFtail == 1 &amp;
                                                                Bfs.table$t &gt; 0] / 2
  Bfs.table$p_tails_match_Bf[Bfs.table$BFtail == 1 &amp;
                               Bfs.table$t &lt; 0] = 1 - Bfs.table$p[Bfs.table$BFtail == 1 &amp;
                                                                    Bfs.table$t &lt; 0] / 2
  
  Bfs.table$p_tails_match_Bf = round(Bfs.table$p_tails_match_Bf, 3)
  Bfs.table$p = Bfs.table$p_tails_match_Bf
  Bfs.table$p_tails_match_Bf = NULL
  return(Bfs.table)
}</code></pre>
</div>
<div id="adjust_intercept_model" class="section level2">
<h2>adjust_intercept_model</h2>
<p>Function to adjust the intercept of the model</p>
<pre class="r"><code>adjust_intercept_model&lt;- function(model, chance, intercept_list = c(&quot;(Intercept)&quot;))
{
  summary = summary(model)$coefficients
  
  for (i in 1:length(intercept_list)){
    summary[intercept_list[i], &quot;Estimate&quot;] = summary[intercept_list[i], &quot;Estimate&quot;]- chance
    summary[intercept_list[i], &quot;z value&quot;] =  summary[intercept_list[i], &quot;Estimate&quot;]/summary[intercept_list[i], &quot;Std. Error&quot;]
    summary[intercept_list[i], &quot;Pr(&gt;|z|)&quot;] =  p =2*pnorm(-abs(summary[intercept_list[i], &quot;z value&quot;])) }
  
  
  summary[intercept_list[i], &quot;Estimate&quot;]
  
  
  return(summary)
  
}</code></pre>
</div>
<div id="bayesfactor-updated" class="section level2">
<h2>BayesFactor <em>updated</em></h2>
<p>Author of the new version: <a
href="http://www.lifesci.sussex.ac.uk/home/Zoltan_Dienes/inference/Bence%20Bayes%20factor%20calculator.html">Bence
Palfi</a>.</p>
<p>Author of the old version: <a
href="http://www.academia.edu/427288/Review_of_Understanding_psychology_as_a_science_An_introduction_to_scientific_and_statistical_inference">Baguely
and Kayne (2010)</a>.</p>
<p>This function computes the Bayes Factor and it’s equivalent to the <a
href="http://www.lifesci.sussex.ac.uk/home/Zoltan_Dienes/inference/Bayes.htm">Dienes
(2008) calculator</a>.</p>
<p>Integration of new and old versions is made available by Catriona
Silvey on 16.04.2021</p>
<p>The BF function has been updated recently. The novel function has
options for a likelihood that is either normal- or t-distributed, and a
model of H1 that is either uniform, or normal or t- (or Cauchy-)
distributed, with the normal/t/cauchy models being 1- or 2-tailed. In
addition, the 1-tailed models are compatible with any mode (unlike the
Dienes, 2008, calculator that assumed that 1-tailed models had a mode of
zero).</p>
<p>The Bf function incorporates both old and new methods (Baguley &amp;
Kaye, 2010, and Bence Palfi’s more recent version). By default, uses
B&amp;K version (for backward compatibility) if using Palfi version,
specify method = “new”.</p>
<pre class="r"><code>Bf&lt;- function(sd, obtained, dfdata = 1, likelihood = c(&quot;normal&quot;, &quot;t&quot;), 
              modeloftheory = c(&quot;normal&quot;, &quot;t&quot;, &quot;cauchy&quot;, &quot;uniform&quot;), uniform, 
              lower=0, upper=1, meanoftheory=0, sdtheory=1, modeoftheory =0, scaleoftheory = 1, 
              dftheory = 1, tail=1, method = &quot;old&quot;){
  if (method == &quot;old&quot;) {
    area &lt;- 0
    if(identical(uniform, 1)){
      theta &lt;- lower
      range &lt;- upper - lower
      incr &lt;- range / 2000
      for (A in -1000:1000){
        theta &lt;- theta + incr
        dist_theta &lt;- 1 / range
        height &lt;- dist_theta * dnorm(obtained, theta, sd)
        area &lt;- area + height * incr
      }
    }else
    {theta &lt;- meanoftheory - 5 * sdtheory
    incr &lt;- sdtheory / 200
    for (A in -1000:1000){
      theta &lt;- theta + incr
      dist_theta &lt;- dnorm(theta, meanoftheory, sdtheory)
      if(identical(tail, 1)){
        if (theta &lt;= 0){
          dist_theta &lt;- 0
        } else {
          dist_theta &lt;- dist_theta * 2
        }
      }
      height &lt;- dist_theta * dnorm(obtained, theta, sd)
      area &lt;- area + height * incr
    }
    }
    LikelihoodTheory &lt;- area
    Likelihoodnull &lt;- dnorm(obtained, 0, sd)
    BayesFactor &lt;- LikelihoodTheory / Likelihoodnull
    ret &lt;- list(&quot;LikelihoodTheory&quot; = LikelihoodTheory,&quot;Likelihoodnull&quot; = Likelihoodnull, &quot;BayesFactor&quot; = BayesFactor)
    ret
  } else if (method == &quot;new&quot;) {
    if(likelihood==&quot;normal&quot;){
      dfdata=10^10
    }
    if(modeloftheory==&quot;normal&quot;){
      dftheory = 10^10
    } else if(modeloftheory==&quot;cauchy&quot;){
      dftheory = 1
    }
    area &lt;- 0
    normarea &lt;- 0
    if(modeloftheory==&quot;uniform&quot;){
      theta &lt;- lower
      range &lt;- upper - lower
      incr &lt;- range / 2000
      for (A in -1000:1000){
        theta &lt;- theta + incr
        dist_theta &lt;- 1 / range
        height &lt;- dist_theta * dt((obtained-theta)/sd, df=dfdata)
        area &lt;- area + height * incr
      }
      LikelihoodTheory &lt;- area
    }else{
      theta &lt;- modeoftheory - 10 * scaleoftheory
      incr &lt;- scaleoftheory/200
      for (A in -2000:2000){
        theta &lt;- theta + incr
        dist_theta &lt;- dt((theta-modeoftheory)/scaleoftheory, df=dftheory)
        if(identical(tail, 1)){
          if (theta &lt;= modeoftheory){
            dist_theta &lt;- 0
          } else {
            dist_theta &lt;- dist_theta * 2
          }
        }
        height &lt;- dist_theta * dt((obtained-theta)/sd, df = dfdata)
        area &lt;- area + height * incr
        normarea &lt;- normarea + dist_theta*incr
      }
      LikelihoodTheory &lt;- area/normarea
    }
    Likelihoodnull &lt;- dt(obtained/sd, df = dfdata)
    BayesFactor &lt;- LikelihoodTheory/Likelihoodnull
    BayesFactor
  }
}</code></pre>
</div>
<div id="bfclassify" class="section level2">
<h2>BfClassify</h2>
<p>Author: Elizabeth Wonnacott</p>
<p>Classifies a Bayes factors as substantial for h1/h0 or ambigious (is
used by addBf_ranges3) is used by Bf_addranges function below</p>
<pre class="r"><code>BfClassify&lt;-function(B)
{
  if(B&lt;=(1/3)){ &quot;h0&quot;}
  else if (B&gt;=3) {&quot;h1&quot;}  
  else {&quot;ambig&quot;}
}</code></pre>
</div>
<div id="bf_model" class="section level2">
<h2>Bf_model</h2>
<p>Author: Elizabeth Wonnacott</p>
<p>This function calls the Bf function described above. Summary should
be the coefficients summary from an lmer/gmer model (obtained via
#summary(model)$coefficients). If its a lmer model, it expects there to
be a columns “df” and “p” (i.e.summary function has been called using
lmerTest package which applieds Kenward-Roger approximation for
denominator degrees of freedom and computes p values). For each
coefficient, the model uses the estimate as the obtained mean and the
Std.Error as the measure of standard error.</p>
<p>The function allows for positive and negtive h1 values. If negative,
since the BF function requires a positive value for sdtheory, both
sdtheory and #obtained are multiplied by -1.</p>
<p>It doesn’t round unless there is an argument “digits” which says how
many dp to round to- in this case the round_df function below is
called.</p>
<pre class="r"><code>Bf_model = function(coeff_summary, coeff_list, h1_list, 
                    h1_motivation, tail_list, digits = &quot;&quot;, method = &quot;old&quot;) {
  if(method == &quot;old&quot;) {
    Bfs = vector(&#39;double&#39;)
    estimates = vector(&#39;double&#39;)
    sterrors = vector(&#39;double&#39;)
    sdtheorys = vector(&#39;double&#39;)
    pvalues = vector(&#39;double&#39;)
    tzvalues = vector(&#39;double&#39;)
    
    for (i in 1:length(coeff_list)) {
      
      sd_error = coeff_summary[coeff_list[i], &quot;Std. Error&quot;]
      obtained = coeff_summary[coeff_list[i], &quot;Estimate&quot;]
      stdtheory = h1_list[i]
      
      
      if(h1_list[i] &lt; 0) {
        stdtheory = h1_list[i] * -1
        obtained = (coeff_summary[coeff_list[i], &quot;Estimate&quot;] * -1)
      }
      
      Bfs[i] = Bf(sd_error, obtained, uniform = 0, meanoftheory = 0, 
                  sdtheory = stdtheory, tail = tail_list[i])$BayesFactor
      estimates[i] = obtained
      sdtheorys[i] = stdtheory
      sterrors[i] = sd_error
      
      if(colnames(coeff_summary)[3] == &quot;z value&quot;) {
        tzlabel = &quot;z&quot;
        tzvalues[i] = abs(coeff_summary[coeff_list[i], 3]) * sign(obtained)
        pvalues[i] = coeff_summary[coeff_list[i], 4]  
      } else if(colnames(coeff_summary)[3] == &quot;df&quot;) {
        tzlabel = &quot;t&quot;
        tzvalues[i] = abs(coeff_summary[coeff_list[i], 4]) * sign(obtained)
        pvalues[i] = coeff_summary[coeff_list[i], 5]  
      } 
    }
    
    df = data.frame(cbind(coeff_list, estimates, sterrors, tzvalues, 
                          pvalues, sdtheorys,  tail_list, Bfs,h1_motivation ))
    colnames(df) = c(&quot;coefficient&quot;, &quot;estimate&quot;, &quot;std.Error&quot;, tzlabel, &quot;p&quot;, 
                     &quot;sdtheory&quot;, &quot;BFtail&quot;, &quot;Bf&quot;, &quot;h1 motivation&quot;)
    df$estimate = as.numeric(as.character(df$estimate))
    df$std.Error = as.numeric(as.character(df$std.Error))
    df$sdtheory = as.numeric(as.character(df$sdtheory))
    
    df$Bf = as.numeric(as.character(df$Bf))
    df$p = as.numeric(as.character(df$p))
    if (tzlabel == &quot;z&quot;) {df$z = as.numeric(as.character(df$z))}
    if (tzlabel == &quot;t&quot;) {df$t = as.numeric(as.character(df$t))}
    if (digits !=  &quot;&quot;) {df = round_df(df, digits)}
    return(df)
  } 
  
  if(method == &quot;new&quot;) {
    Bfs = vector(&#39;double&#39;)
    estimates = vector(&#39;double&#39;)
    sterrors = vector(&#39;double&#39;)
    sdtheorys = vector(&#39;double&#39;)
    pvalues = vector(&#39;double&#39;)
    tzvalues = vector(&#39;double&#39;)
    dfvalues = vector(&#39;double&#39;)
    
    if(colnames(coeff_summary)[3] == &quot;df&quot;){tzlabel = &quot;t&quot;}
    if(colnames(coeff_summary)[3] == &quot;z value&quot;){tzlabel = &quot;z&quot;}
    
    for (i in 1:length(coeff_list)) {
      
      sd = coeff_summary[coeff_list[i], &quot;Std. Error&quot;]
      obtained = coeff_summary[coeff_list[i], &quot;Estimate&quot;]
      stdtheory = h1_list[i]
      
      if(h1_list[i] &lt; 0) {
        stdtheory = h1_list[i] * -1
        obtained = (coeff_summary[coeff_list[i], &quot;Estimate&quot;] * -1)}
      
      
      if(tzlabel == &quot;t&quot;) {
        dfdata = coeff_summary[coeff_list[i], &quot;df&quot;]  
        Bfs[i] = Bf(sd, obtained, dfdata, likelihood = c(&quot;t&quot;), 
                    modeloftheory = c(&quot;normal&quot;), modeoftheory = 0, 
                    scaleoftheory = stdtheory, tail = tail_list[i], 
                    method = &quot;new&quot;)
      }
      if(tzlabel == &quot;z&quot;) {
        Bfs[i] = Bf(sd, obtained, likelihood = c(&quot;normal&quot;), 
                    modeloftheory = c(&quot;normal&quot;), modeoftheory = 0, 
                    scaleoftheory = stdtheory, tail = tail_list[i], 
                    method = &quot;new&quot;)
      }
      
      estimates[i] = obtained
      sdtheorys[i] = stdtheory
      sterrors[i] = sd
      
      if(tzlabel == &quot;z&quot;) {
        
        tzvalues[i] = abs(coeff_summary[coeff_list[i], 3]) * sign(obtained)
        pvalues[i] = coeff_summary[coeff_list[i], 4]  
      } else if(tzlabel == &quot;t&quot;) {
        dfvalues[i] = dfdata
        tzvalues[i] = abs(coeff_summary[coeff_list[i], 4]) * sign(obtained)
        pvalues[i] = coeff_summary[coeff_list[i], 5]  
      } 
    }
    
    if(tzlabel == &quot;z&quot;) {
      df = data.frame(cbind(coeff_list, estimates, sterrors, tzvalues, pvalues, sdtheorys,  tail_list, Bfs, h1_motivation))
      colnames(df) = c(&quot;coefficient&quot;, &quot;estimate&quot;, &quot;std.Error&quot;, tzlabel, &quot;p&quot;, &quot;sdtheory&quot;, &quot;BFtail&quot;, &quot;Bf&quot;, &quot;h1 motivation&quot;)
      
    }
    if(tzlabel == &quot;t&quot;) {df = data.frame(cbind(coeff_list, estimates, sterrors, tzvalues, dfvalues, pvalues, sdtheorys,  tail_list, Bfs, h1_motivation))
    colnames(df) = c(&quot;coefficient&quot;, &quot;estimate&quot;, &quot;std.Error&quot;, tzlabel, &quot;df&quot;, &quot;p&quot;, &quot;sdtheory&quot;, &quot;BFtail&quot;, &quot;Bf&quot;, &quot;h1 motivation&quot;)
    
    }
    
    df$estimate = as.numeric(as.character(df$estimate))
    df$std.Error = as.numeric(as.character(df$std.Error))
    df$sdtheory = as.numeric(as.character(df$sdtheory))
    
    df$Bf = as.numeric(as.character(df$Bf))
    df$p = as.numeric(as.character(df$p))
    if (tzlabel == &quot;z&quot;) {df$z = as.numeric(as.character(df$z))}
    if (tzlabel == &quot;t&quot;) {df$t = as.numeric(as.character(df$t))}
    if (digits !=  &quot;&quot;) {df = round_df(df, digits)}
    return(df)
  } 
}</code></pre>
</div>
<div id="bf_powercalc" class="section level2">
<h2>Bf_powercalc</h2>
<p>Author: Elizabeth Wonnacott.</p>
<p>This works with the Bf function above. It requires the same values as
that function (i.e. the obtained mean and SE for the current sample, a
value for the predicted mean, which is set to be sdtheory (with
meanoftheory=0), and the current number of participants N). However
rather than return BF for current sample, it works out what the BF would
be for a range of different subject numbers (assuming that the SE scales
with sqrt(N)).</p>
<pre class="r"><code>Bf_powercalc&lt;-function(sd, obtained, uniform, lower=0, upper=1, meanoftheory=0, sdtheory=1, tail=1, N, min, max)
{
  
  x = c(0)
  y = c(0)
  # note: working out what the difference between N and df is (for the contrast between two groups, this is 2; for constraints where there is 4 groups this will be 3, etc.)  
  for(newN in min : max)
  {
    B = as.numeric(Bf(sd = sd*sqrt(N/newN), obtained, uniform, lower, upper, meanoftheory, sdtheory, tail)[3])
    x= append(x,newN)  
    y= append(y,B)
    output = cbind(x,y)
    
  } 
  output = output[-1,] 
  return(output) 
}</code></pre>
</div>
<div id="bf_range" class="section level2">
<h2>Bf_range</h2>
<p>Author: Elizabeth Wonnacott Updated by: Catriona Silvey on
16.04.2021</p>
<p>This works with the Bf function above. It requires the obtained mean
and SE for the current sample and works out what the BF would be for a
range of predicted means (which are set to be sdtheoryrange (with
meanoftheory=0)).</p>
<p>Bf_range function can be used with both old and new versions of Bf
function. By default, uses old version (for backward compatibility) if
using new version, specify method = “new”. The “new” function is an
update of the Bf_range function in order to use the new Bf updated
version. It works with normal, t and Cauchy H1s, and normal or t
likelihoods.</p>
<pre class="r"><code>Bf_range &lt;- function(sd, obtained, dfdata = 1, likelihood = c(&quot;normal&quot;, &quot;t&quot;), 
                     modeloftheory= c(&quot;normal&quot;,&quot;t&quot;,&quot;cauchy&quot;) , meanoftheory = 0,
                     modeoftheory = 0, sdtheoryrange, dftheory = 1, tail = 1, method = &quot;old&quot;)
{
  if (method == &quot;old&quot;) {
    
    x = c(0)
    y = c(0)
    
    for(sdi in sdtheoryrange)
    {
      #sdi = sdtheoryrange[1]
      # uses old Bf method
      B = as.numeric(Bf(sd, obtained, meanoftheory=0, uniform = 0, sdtheory=sdi, tail=tail)[3])
      
      #following line corrects for the fact that the calcuator does not correctly compute BF when sdtheory==0; this code ensures that if sdtheory ==0, BF=1
      
      if (sdi ==0 ) {B=1}
      
      x= append(x,sdi)  
      y= append(y,B)
      output = cbind(x,y)
      
    }
    
  }
  else if (method == &quot;new&quot;) {
    
    x = c(0)
    y = c(0)
    
    for(sdi in sdtheoryrange)
    {
      #sdi = sdtheoryrange[1]
      # uses new Bf method
      B = as.numeric(Bf(sd = sd, obtained = obtained, dfdata = dfdata, likelihood = likelihood, 
                        modeloftheory = modeloftheory, modeoftheory=modeoftheory, scaleoftheory=sdi, 
                        dftheory = dftheory, tail = tail, method=&quot;new&quot;))
      
      #following line corrects for the fact that the calcuator does not correctly compute BF when sdtheory==0; this code ensures that if sdtheory ==0, BF=1
      
      if (sdi ==0 ) {B=1}
      
      x= append(x,sdi)  
      y= append(y,B)
      output = cbind(x,y)
      
    }
    
  }
  output = output[-1,] 
  colnames(output) = c(&quot;sdtheory&quot;, &quot;BF&quot;)
  return(output) 
}</code></pre>
</div>
<div id="bf_set" class="section level2">
<h2>Bf_set</h2>
<p>Bf_set is a wrapper around Bf which allows us to caculate a set of
BFs and put them in a table. It can only be used with non-uniform method
and each h1 must be positive (as for original calculator).</p>
<pre class="r"><code>Bf_set &lt;-function(names_list, meandiff_list, sd_list,  h1_list, tail_list)
{
  Bfs = vector(&#39;double&#39;)
  for (i in 1:length(meandiff_list)){
    Bfs[i] = Bf(sd_list[i], meandiff_list[i], uniform = 0, meanoftheory = 0, sdtheory=h1_list[i] , tail = tail_list[i])$BayesFactor
    
  }
  
  df = data.frame(names_list, cbind(round(meandiff_list,3), round(sd_list,3),  h1_list, round(Bfs,3)))
  colnames(df) = c(&quot;Contrast&quot;, &quot;Mean difference&quot;, &quot;SE&quot;, &quot;H1 estimate&quot;, &quot;BF&quot; )
  return(df)
  
  kable(df)
}</code></pre>
</div>
<div id="confidence-interval-calculators-95-ci" class="section level2">
<h2>confidence interval calculators (95% CI)</h2>
<p>lower_ci.R and upper_ci.R are functions made available publicly in
this <a
href="https://community.rstudio.com/t/computing-confidence-intervals-with-dplyr/31868">Rcommunity
post</a></p>
<div id="example" class="section level3">
<h3>Example:</h3>
<pre class="r"><code>library(tidyverse)
test &lt;- data.frame(
  n = c(298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3),
  run = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
          1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
  mAP = c(0.8112, 0.8006, 0.8076, 0.7999, 0.8067, 0.8046, 0.8004, 0.799,
          0.8052, 0.8002, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.8333, 0.8333,
          0.8333, 1, 0.8333, 1, 1, 0.8333, 1, 1)
)

lower_ci &lt;- function(mean, se, n, conf_level = 0.95){
  lower_ci &lt;- mean - qt(1 - ((1 - conf_level) / 2), n - 1) * se
}

upper_ci &lt;- function(mean, se, n, conf_level = 0.95){
  upper_ci &lt;- mean + qt(1 - ((1 - conf_level) / 2), n - 1) * se
}

foobar &lt;- test %&gt;%
  group_by(n) %&gt;%
  summarise(smean = mean(mAP, na.rm = TRUE),
            ssd = sd(mAP, na.rm = TRUE)) %&gt;%
  mutate(se = ssd / sqrt(n),
         lower_ci = lower_ci(smean, se, n),
         upper_ci = upper_ci(smean, se, n))

foobar         </code></pre>
<p>Functions below:</p>
<pre class="r"><code>lower_ci &lt;- function(mean, se, n, conf_level = 0.95){
  lower_ci &lt;- mean - qt(1 - ((1 - conf_level) / 2), n - 1) * se
}

upper_ci &lt;- function(mean, se, n, conf_level = 0.95){
  upper_ci &lt;- mean + qt(1 - ((1 - conf_level) / 2), n - 1) * se
}</code></pre>
</div>
</div>
<div id="deleterandomrows" class="section level2">
<h2>deleteRandomRows</h2>
<p>This takes a dataframe (df) and an integer (n) and returns a df which
has n rows randomly deleted</p>
<pre class="r"><code>deleteRandomRows = function(df,n){
  indices &lt;- sample(1:nrow(df), n)
  df &lt;- df[-indices,]
  return(df)
}</code></pre>
</div>
<div id="download_from_gorilla" class="section level2">
<h2>download_from_Gorilla</h2>
<p>Author: Eva Viviani</p>
<p>This function is a wrapper around <a
href="https://github.com/University-of-Sheffield-EduTech/data-endpoint-gorilla.io/blob/master/Preview_Downloader_Script.R?fbclid=IwAR2zI3ZHgFKqZchCI1yEghEaGXgoDtJ_Fr3OWOGG-Iz_ki6jk30clYG3aR8">Ferenc
Igali’s script.</a></p>
<p>It downloads the data from Gorilla automatically, provided that you
set your Gorilla login credentials into R.</p>
<p><strong>TO SET YOUR GORILLA LOGIN CREDENTIALS:</strong> Install
“keyring” package and run in R the following lines:</p>
<ul>
<li>keyring::key_set(service = “Gorilla”, username = “<a
href="mailto:eva.viviani@education.ox.ac.uk"
class="email">eva.viviani@education.ox.ac.uk</a>”)</li>
</ul>
<p>Change the “username” with the email you use for login into Gorilla.
Keyring package will ask and save your password within R. These
information are passed into the function below to log into Gorilla and
access your data. <strong>Only if you have set your login credentials,
you can run the “download_from_Gorilla” function below.</strong></p>
<p>Arguments:</p>
<ul>
<li><p>output: a character string with the name of the folder where the
downloaded file is saved</p></li>
<li><p>ulr: a character string, or a vector of characters, with the
links (starting with “https”) that I want to download</p></li>
<li><p>myGorillaemail: the email that I use to log into Gorilla</p></li>
</ul>
<div id="example-1" class="section level3">
<h3>Example:</h3>
<pre class="r"><code>output &lt;- c(&quot;C:/Users/...&quot;)
previewDownloadFile &lt;- read.csv(&quot;data.csv&quot;) #this is a preview file of the eyetracker zone that contains in the &quot;Response&quot; column my links. One for each trial.
url &lt;- previewDownloadFile[grepl(&quot;https&quot;, previewDownloadFile$Response),]$Response
download_from_Gorilla(output, url, &quot;eva.viviani@education.ox.ac.uk&quot;)</code></pre>
<p>Function below:</p>
<pre class="r"><code>download_from_Gorilla &lt;-function(output, url, myGorillaemail){
  if (!require(downloader)) {
    stop(&quot;downloader not installed&quot;)
  } else if (!require(keyring)){
    stop(&quot;keyring not installed&quot;)
  } else if (!require(httr)){
    stop(&quot;httr not installed&quot;) 
  } else {
    print(&quot;------ start download -------&quot;)
  };
  
  #---------------------- get credentials and login ----------------------------#
  login &lt;- list(
    email = myGorillaemail, 
    password = keyring::key_get(&quot;Gorilla&quot;, myGorillaemail))
  login_res &lt;- POST(&quot;https://gorilla.sc/api/login&quot;, body = login, encode = &quot;form&quot;)
  
  #---------------------- cycle over the list of urls --------------------------#
  for (i in 1:length(url)){
    file_end &lt;- &quot;&quot;
    experiment_download_url &lt;- GET(url[i])
    content_type_you_need_to_save &lt;- experiment_download_url$headers$`content-type`
    
    #------------------------- check content type -------------------------------# 
    if (content_type_you_need_to_save == &quot;text/csv&quot;) {
      file_end &lt;- &quot;.csv&quot;
    } else if (content_type_you_need_to_save == &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;) {
      file_end &lt;- &quot;.xlsx&quot;
    } else if (content_type_you_need_to_save == &quot;audio/wav&quot;) {
      file_end &lt;- &quot;.weba&quot;
    } else if (content_type_you_need_to_save == &quot;video/webm;codecs=vp8&quot;) {
      file_end &lt;- &quot;.webm&quot;
    }
    
    file_download_url &lt;- experiment_download_url$url
    file_name_saver &lt;- paste0(substring(as.character(url[i]),54,nchar(as.character(url[i]))))
    
    #download the file
    downloader::download(file_download_url, paste0(output, file_name_saver), mode = &quot;wb&quot;, quiet = T)
    print(paste0(&quot;file &quot;,i))
  }
  print(&quot;------ download done -------&quot;)
}</code></pre>
</div>
</div>
<div id="filter2" class="section level2">
<h2>filter2</h2>
<p>This is a function which filters a column of data removing values
which are some number of standard deviations above/below the mean for
that participant, possibly in some condition/subcondition.</p>
<ul>
<li><p>im: the input matrix (a data frame)</p></li>
<li><p>svn: a list of the names of factors to be group by (subject name
+ one or more conditions)</p></li>
<li><p>fn: the name of the column containing the data to be
filtered</p></li>
<li><p>lim: how many standard deviations above/below the mean to
filter</p></li>
</ul>
<p>The function returns an input matrix identical to the input matrix
but with an additional columns giving the group means and the “filtered”
data.</p>
<pre class="r"><code>filter2 = function(im, svn, fn, lim)
{
  ## work out means lisfor each subject for each word
  
  x = list()
  y = &quot;&quot;
  
  for(n in svn) x=append(im[n],x)
  for(n in svn) y=paste(y,n,sep=&quot;_&quot;)
  
  means = aggregate(im[fn], by = x, mean, na.rm=T)
  head(means)
  nocols = dim(means)[2]
  colnames(means)[nocols] = &quot;means&quot;
  
  sds = aggregate(im[fn], by = x, sd, na.rm=T)
  head(sds)
  nocols = dim(sds)[2]
  colnames(sds)[nocols] = &quot;sds&quot;
  
  gs = merge(means,sds)
  
  ## because if there is just one value it doesn&#39;t have a stand deviation and don&#39;t want to just disregard all of these
  gs$sds[is.na(gs$sds)] = 0 
  
  gs$max = gs$means + lim*gs$sds
  gs$min = gs$means- lim*gs$sds
  
  im2 = merge(im,gs, sort=F)
  
  
  im2[paste(fn,&quot;filt&quot;,sep=&quot;&quot;)] = im2[fn]
  cn= dim(im2)[2] ## get colnumber (last one added)
  
  im2[,cn][im2[,fn]&gt; im2$max] = &quot;&quot;
  
  im2[,cn][im2[,fn]&lt; im2$min] = &quot;&quot;
  
  im2[,cn]= as.numeric(im2[,cn])
  
  
  names(im2)[names(im2)==&quot;means&quot;] = paste(&quot;mean&quot;, y, sep=&quot;_&quot;) 
  names(im2)[names(im2)==&quot;sds&quot;] = paste(&quot;sd&quot;, y, sep=&quot;_&quot;) 
  names(im2)[names(im2)==&quot;max&quot;] = paste(&quot;max&quot;, y, sep=&quot;_&quot;) 
  names(im2)[names(im2)==&quot;min&quot;] = paste(&quot;min&quot;, y, sep=&quot;_&quot;) 
  
  return(im2)
}</code></pre>
</div>
<div id="generate_bin" class="section level2">
<h2>generate_bin</h2>
<p>Author: Catriona Silvey</p>
<p>This function generates some multilevel binary data.</p>
<p>Arguments:</p>
<ul>
<li><p>n_subj = number of subjects</p></li>
<li><p>n_obs = total number of trials per subject</p></li>
<li><p>alpha = veridical grand mean log odds performance</p></li>
<li><p>beta1 = veridical effect of cond1</p></li>
<li><p>beta2 = veridical effect of cond2</p></li>
<li><p>beta3 = veridical cond1 * cond2 interaction effect</p></li>
<li><p>subj_corrs = list of correlations between random effects</p></li>
<li><p>subj_tau = list of SDs of random effects</p></li>
</ul>
<pre class="r"><code>generate_bin &lt;- function(n_subj, n_obs, alpha, beta1, beta2, beta3, subj_corrs, subj_tau) {
  # make data frame where number of rows = number of subjects * number of trials per subject
  data &lt;- data.frame(matrix(0, ncol=0, nrow = n_subj * n_obs))
  # make subject vector and add to this data frame
  data$subject &lt;- as.factor(rep(seq(1:n_subj), each = n_obs))
  # make condition 1 vector - within subjects
  # half trials one value, half trials the other
  data$cond1 &lt;- as.factor(rep(c(0,1), each = n_obs/2))
  # make centred version
  data$c_cond1 &lt;- as.numeric(data$cond1) - mean(as.numeric(data$cond1))
  # make condition 2 vector - also within subjects
  # 1/4 trials one value, 1/4 trials the other, then repeat
  # this ensures cond1 and cond2 are not identical
  data$cond2 &lt;- as.factor(rep(c(0,1), each = n_obs/4))
  # make centred version
  data$c_cond2 &lt;- as.numeric(data$cond2) - mean(as.numeric(data$cond2))
  # for subject effects
  # first, we put the correlations between the random effects in a matrix
  # * if changing to simulate fewer random effects &amp; hence fewer correlations, 
  # this will need to be adjusted
  corr_matrix &lt;- matrix(c(1, subj_corrs[1], subj_corrs[2], subj_corrs[3],
                          subj_corrs[1], 1, subj_corrs[4], subj_corrs[5],
                          subj_corrs[2], subj_corrs[4], 1, subj_corrs[6],
                          subj_corrs[3], subj_corrs[5], subj_corrs[6], 1), nrow = 4)
  # next, construct variance covariance matrix for subject effects
  # We multiply the subject effect sds (in matrix form) by the correlation matrix
  # and then again by the subject effect sds
  # so we end up with the sds squared (on the diagonal) = variance, 
  # and covariances between each pair of subject effects on the off-diagonal
  # * if changing to simulate fewer random effects, this should still work fine,
  # assuming corr_matrix has been adjusted appropriately
  subj_v_cov &lt;- diag(subj_tau) %*% corr_matrix %*% diag(subj_tau)
  # Create the correlated subject effects, using mvrnorm to sample from multivariate normal distribution
  # means of subject intercepts and slopes are 0
  u &lt;- mvrnorm(n = n_subj, c(0,0,0,0), subj_v_cov)
  # check the correlation - this should be fairly accurate in large samples
  # print(cor(u))
  # check the SDs - again, should be fairly accurate in large samples
  # print(sd(u[,1]))
  # print(sd(u[,2]))
  # print(sd(u[,3]))
  # print(sd(u[,4]))
  # finally, generate data on the basis of these parameters
  data &lt;- data %&gt;%
    mutate(
      # We first calculate the linear predictor eta for each row in the data frame
      # = overall intercept + subject intercept +
      eta = alpha + u[data$subject,1] +
        # cond1 value * (cond1 fixed effect + cond1 random slope) +
        data$c_cond1 * (beta1 + u[data$subject,2]) + 
        # cond2 value * (cond2 fixed effect + cond2 random slope) +
        data$c_cond2 * (beta2 + u[data$subject,3]) +
        # cond1 * cond2 value * (interaction fixed effect + interaction random slope) +
        (data$c_cond1 * data$c_cond2) * (beta3 + u[data$subject,4]),
      # then transform by inverse logit to a probability (for this combo of subject/condition)
      mu = inv.logit(eta),
      # finally, generate a 0 or 1 for this row based on the probability for this subject/condition
      y = rbinom(nrow(data),1,mu))
  return(data)
}</code></pre>
</div>
<div id="getmode" class="section level2">
<h2>getmode</h2>
<p>Author: <a
href="https://www.tutorialspoint.com/r/r_mean_median_mode.htm">Tutorials
point</a>.</p>
<pre class="r"><code>getmode &lt;- function(v) {
  uniqv &lt;- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}</code></pre>
</div>
<div id="get_coeffs" class="section level2">
<h2>get_coeffs</h2>
<p>This function allows us to inspect particular coefficients from the
output of an LME model by putting them in table.</p>
<ul>
<li><p>x: the output returned when running lmer or glmer (i.e. an object
of type lmerMod or glmerMod)</p></li>
<li><p>list: a list of the names of the coefficients to be extracted
(e.g. c(“variable1”, “variable1:variable2”))</p></li>
</ul>
<pre class="r"><code>get_coeffs &lt;- function(x,list){(as.data.frame(summary(x)$coefficients)[list,])}</code></pre>
</div>
<div id="get_coeffs2" class="section level2">
<h2>get_coeffs2</h2>
<p>outputs a set of specific coefficients for an lmer model</p>
<p>x must match the form summary(lmermodel)$coefficients as applied to
the output of an lmermodel. List should be a list of the coefficients
which should be reported.</p>
<pre class="r"><code>get_coeffs2 &lt;- function(x,list){(x[list,])}</code></pre>
</div>
<div id="inverse_log_odd" class="section level2">
<h2>inverse_log_odd</h2>
<p>It takes a log-odds value and calculates the proportion</p>
<pre class="r"><code>inverse_log_odd&lt;-function(lo) {exp(lo)/(1 + exp(lo))} </code></pre>
</div>
<div id="lizcenter" class="section level2">
<h2>lizCenter</h2>
<p>Author: Elizabeth Wonnacott.</p>
<p>This function provides a wrapper around myCenter allowing to center a
specific list of variables from a dataframe. The input is a dataframe
(x) and a list of the names of the variables which you wish to center
(listfname). The output is a copy of the dataframe with a column
(numeric) added for each of the centered variables with each one
labelled with it’s previous name with “.ct” appended. For example, if x
is a dataframe with columns “a” and “b” lizCenter(x, list(“a”, “b”))
will return a dataframe with two additional columns, a.ct and b.ct,
which are numeric, centered codings of the corresponding variables.</p>
<pre class="r"><code>lizCenter= function(x, listfname) 
{
  for (i in 1:length(listfname)) 
  {
    fname = as.character(listfname[i])
    x[paste(fname,&quot;.ct&quot;, sep=&quot;&quot;)] = myCenter(x[fname])
  }
  
  return(x)
}</code></pre>
</div>
<div id="lizcenter2" class="section level2">
<h2>lizCenter2</h2>
<p>This function provides a wrapper around lizCenter which removes rows
with missing data in the the DV before centering- note the df will have
less rows as well as the centered variables (so will need to be careful
with this is working with multiple dvs).</p>
<ul>
<li><p>dv - a string which is the column name of the column in the
dataframe with the dv</p></li>
<li><p>x: data frame</p></li>
<li><p>listfname: a list of the variables to be centered
(e.g. list(variable1,variable2))</p></li>
</ul>
<p>The output is a copy of the data frame with a column (always a
numeric variable) added for each of the centered variables. These
columns are labeled with the column’s previous name, but with “.ct”
appended (e.g., “variable1” will become “variable1.ct”).</p>
<pre class="r"><code>lizCenter2= function(x, listfname, dv) 
{
  x= droplevels(subset(x, is.na(x[as.character(dv)])==FALSE))
  x = lizCenter(x, listfname)
  
  
  return(x)
}</code></pre>
</div>
<div id="lizcontrasts" class="section level2">
<h2>lizContrasts</h2>
<p>Author: Elizabeth Wonnacott.</p>
<p>This function implements a <a
href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/#SIMPLE">simple
coding scheme</a>. It creates two centered dummy variables which stand
in place of a three way factor (condition). This allows us to inspect
each contrast separately against a reference level, as well as their
interactions with other factors. Other fixed effects in the model can be
evaluated as the average effects across all levels of the factor. Note
that the intercept corresponds to the mean of cell means, sometimes
referred as grand mean.</p>
<p>The function takes a data frame (d), a factor from that database
(condition), which must have three levels, and the name of the level of
the factor which is to be used as the baseline for the contrasts
(baselevel).</p>
<pre class="r"><code>lizContrasts= function(d, condition, baselevel) 
{
  
  condition = factor(condition)
  condition = relevel(condition, baselevel)
  
  a= (contrasts(condition)-apply(contrasts(condition),2,mean))
  d$dummy1[condition== rownames(a)[1]] &lt;- a[1] 
  d$dummy1[condition== rownames(a)[2]] &lt;- a[2] 
  d$dummy1[condition== rownames(a)[3]] &lt;- a[3] 
  
  d$dummy2[condition== rownames(a)[1]] &lt;- a[4] 
  d$dummy2[condition== rownames(a)[2]] &lt;- a[5] 
  d$dummy2[condition== rownames(a)[3]] &lt;- a[6] 
  
  name1 = paste(baselevel, rownames(a)[2],sep=&quot;_VERSUS_&quot;)
  name2 = paste(baselevel, rownames(a)[3],sep=&quot;_VERSUS_&quot;)
  
  d[name1] = d$dummy1 
  d[name2] = d$dummy2 
  
  d$dummy1 &lt;-NULL 
  d$dummy2 &lt;-NULL 
  
  return(d)
}</code></pre>
</div>
<div id="lizcontrasts4" class="section level2">
<h2>lizContrasts4</h2>
<p>Author: Elizabeth Wonnacott.</p>
<p>This function is a version of the previous <a
href="https://n400peanuts.github.io/languagelearninglab/usefulFunctions-explained.html#lizContrasts">lizContrasts</a>
function but to be used to create three centered dummy variables which
stand in place of a four-way factor (condition). Notes that this
function implements a <a
href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/#SIMPLE">simple
coding scheme</a>. It creates three centered dummy variables which stand
in place of a three way factor (condition). This allows us to inspect
each contrast separately against a reference level, as well as their
interactions with other factors. Other fixed effects in the model can be
evaluated as the average effects across all levels of the factor. Note
that the intercept corresponds to the mean of cell means, sometimes
referred as grand mean.</p>
<pre class="r"><code>lizContrasts4= function(d, condition, baselevel) 
{
  #condition = pictest$condition
  condition = factor(condition)
  condition = relevel(condition, baselevel)
  a= (contrasts(condition)-apply(contrasts(condition),2,mean))
  
  d$dummy1[condition== rownames(a)[1]] &lt;- a[1] 
  d$dummy1[condition== rownames(a)[2]] &lt;- a[2] 
  d$dummy1[condition== rownames(a)[3]] &lt;- a[3] 
  d$dummy1[condition== rownames(a)[4]] &lt;- a[4] 
  d$dummy2[condition== rownames(a)[1]] &lt;- a[5] 
  d$dummy2[condition== rownames(a)[2]] &lt;- a[6] 
  d$dummy2[condition== rownames(a)[3]] &lt;- a[7] 
  d$dummy2[condition== rownames(a)[4]] &lt;- a[8] 
  d$dummy3[condition== rownames(a)[1]] &lt;- a[9] 
  d$dummy3[condition== rownames(a)[2]] &lt;- a[10] 
  d$dummy3[condition== rownames(a)[3]] &lt;- a[11] 
  d$dummy3[condition== rownames(a)[4]] &lt;- a[12] 
  
  name1 = paste(baselevel, rownames(a)[2],sep=&quot;_VERSUS_&quot;)
  name2 = paste(baselevel, rownames(a)[3],sep=&quot;_VERSUS_&quot;)
  name3 = paste(baselevel, rownames(a)[4],sep=&quot;_VERSUS_&quot;)
  
  d[name1] = d$dummy1 
  d[name2] = d$dummy2 
  d[name3] = d$dummy3 
  
  d$dummy1 &lt;-NULL 
  d$dummy2 &lt;-NULL 
  d$dummy3 &lt;-NULL 
  
  return(d)
}</code></pre>
</div>
<div id="loadfunctionsgithub" class="section level2">
<h2>loadFunctionsGithub</h2>
<p>Author: Eva Viviani.</p>
<p>This function loads automatically all the functions stored in the
<em>/tools</em> folder. It requires three arguments:</p>
<ul>
<li><p>urlFolder that is the url of the github at the master tree
level</p></li>
<li><p>urlRaw, that is the raw address of the folder</p></li>
<li><p>listFunctions that is a vector containing the functions I want to
download. If I want all of them, simply leave it empty, i.e.,
listFunctions &lt;- NULL, otherwise specify the functions with the “.R”
extention like this: e.g., listFunctions &lt;-
c(“Bf.R”,“lizContrasts.R”,“getmode.R”)</p></li>
</ul>
<pre class="r"><code>urlFolder &lt;- &#39;https://api.github.com/repos/n400peanuts/languagelearninglab/git/trees/master?recursive=1&#39;
urlRaw &lt;- &#39;https://raw.githubusercontent.com/n400peanuts/languagelearninglab/master/tools/&#39;
listFunctions &lt;- NULL #this needs to be a list, e.g., listFunctions &lt;- c(&quot;Bf.R&quot;,&quot;lizContrasts.R&quot;,&quot;getmode.R&quot;)</code></pre>
<pre class="r"><code>loadFunctionsGithub &lt;-function(urlFolder, urlRaw, listFunctions){
  if (!require(httr)) {
    stop(&quot;httr not installed&quot;)
  } 
  else {
    print(&#39;----Downloading. Please wait----&#39;)
  };
  httr::GET(urlFolder)-&gt; req
  stop_for_status(req)
  filelist &lt;- unlist(lapply(content(req)$tree, &quot;[&quot;, &quot;path&quot;), use.names = F)
  urlFunctions &lt;- grep(&quot;docs/tools/&quot;, filelist, value = TRUE, fixed = TRUE)
  gsub(&quot;docs/tools/&quot;, &quot;&quot;, urlFunctions) -&gt; functions
  if (length(listFunctions) == 0){ #load all
    for (i in 1:length(functions)){
      httr::GET(paste0(urlRaw, functions[i]), ssl.verifypeer = FALSE)-&gt; temp
      content(temp)-&gt;p3
      eval(parse(text = p3), envir = .GlobalEnv)
    } 
  } else {
    functions[functions %in% listFunctions]-&gt; functionsIlike
    for (i in 1:length(functionsIlike)){
      httr::GET(paste0(urlRaw, functionsIlike[i]), ssl.verifypeer = FALSE)-&gt; temp
      content(temp)-&gt;p3
      eval(parse(text = p3), envir = .GlobalEnv)
    }
  };
  print(&#39;----Download completed----&#39;)
}</code></pre>
</div>
<div id="logodds" class="section level2">
<h2>logodds</h2>
<p>This function takes a percentage p and returns the logodds value.</p>
<pre class="r"><code>logodds &lt;- function(p){log(p/(100-p))} </code></pre>
</div>
<div id="mycenter" class="section level2">
<h2>myCenter</h2>
<p>Author: <a
href="https://hlplab.wordpress.com/2009/04/27/centering-several-variables/">Florian
Jaegers</a>.</p>
<p>This function outputs the centered values of a variable, which can be
a numeric variable, a factor, or a data frame.</p>
<p>From Florian’s blog:</p>
<ul>
<li><p>If the input is a numeric variable, the output is the centered
variable.</p></li>
<li><p>If the input is a factor, the output is a numeric variable with
centered factor level values. That is, the factor’s levels are converted
into numerical values in their inherent order (if not specified
otherwise, R defaults to alphanumerical order). More specifically, this
centers any binary factor so that the value below 0 will be the 1st
level of the original factor, and the value above 0 will be the 2nd
level.</p></li>
<li><p>If the input is a data frame or matrix, the output is a new
matrix of the same dimension and with the centered values and column
names that correspond to the colnames() of the input preceded by “c”
(e.g. “Variable1” will be “cVariable1”).</p></li>
</ul>
<pre class="r"><code>myCenter &lt;- function(x) {
  if (is.numeric(x)) { return(x - mean(x, na.rm=T)) }
  if (is.factor(x)) {
    x= as.numeric(x)
    return(x - mean(x, na.rm=T))
  }
  if (is.data.frame(x) || is.matrix(x)) {
    m= matrix(nrow=nrow(x), ncol=ncol(x))
    colnames(m)= paste(&quot;c&quot;, colnames(x), sep=&quot;&quot;)
    
    for (i in 1:ncol(x)) {
      
      m[,i]= myCenter(x[,i])
    }
    return(as.data.frame(m))
  }
}</code></pre>
</div>
<div id="normdatawithin" class="section level2">
<h2>normDataWithin</h2>
<p>Author: <a
href="http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper">Cookbook
for R</a>.</p>
<p>This function is used by the SummarySEWithin function above. From
that website:</p>
<p>Norms the data within specified groups in a data frame; it normalizes
each subject (identified by idvar) so that they have the same mean,
within each group specified by betweenvars.</p>
<ul>
<li><p>data: a data frame</p></li>
<li><p>idvar: the name of a column that identifies each subject (or
matched subjects)</p></li>
<li><p>measurevar: the name of a column that contains the variable to be
summarized</p></li>
<li><p>betweenvars: a vector containing names of columns that are
between-subjects variables</p></li>
<li><p>na.rm: a boolean that indicates whether to ignore NA’s</p></li>
</ul>
<pre class="r"><code>normDataWithin &lt;- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
  #library(plyr)
  
  # Measure var on left, idvar + between vars on right of formula.
  data.subjMean &lt;- ddply(data, c(idvar, betweenvars), .drop=.drop,
                         .fun = function(xx, col, na.rm) {
                           c(subjMean = mean(xx[,col], na.rm=na.rm))
                         },
                         measurevar,
                         na.rm
  )
  
  # Put the subject means with original data
  data &lt;- merge(data, data.subjMean)
  
  # Get the normalized data in a new column
  measureNormedVar &lt;- paste(measurevar, &quot;_norm&quot;, sep=&quot;&quot;)
  data[,measureNormedVar] &lt;- data[,measurevar] - data[,&quot;subjMean&quot;] +
    mean(data[,measurevar], na.rm=na.rm)
  
  # Remove this subject mean column
  data$subjMean &lt;- NULL
  
  return(data)
}</code></pre>
</div>
<div id="num.decimals" class="section level2">
<h2>num.decimals</h2>
<p>Author: Elizabeth Wonnacott</p>
<pre class="r"><code>num.decimals &lt;- function(x) {
  stopifnot(class(x)==&quot;numeric&quot;)
  x &lt;- sub(&quot;0+$&quot;,&quot;&quot;,x)
  x &lt;- sub(&quot;^.+[.]&quot;,&quot;&quot;,x)
  nchar(x)
}</code></pre>
</div>
<div id="percentage" class="section level2">
<h2>percentage</h2>
<p>This function does the reverse of the function above.</p>
<pre class="r"><code>percentage &lt;- function(logodds) {(exp(logodds)/(1+exp(logodds)) ) * 100}</code></pre>
</div>
<div id="round_df" class="section level2">
<h2>round_df</h2>
<p>Author: Elizabeth Wonnacott</p>
<p>Take a data frame “df” and round any numeric column by to the number
of dp given in digits.</p>
<pre class="r"><code>round_df &lt;- function(df, digits) {
  for(i in 1: ncol(df)){
    
    if (is.numeric(df[,i])) { 
      df[,i]= round(df[,i],digits) }
  }
  
  return(df)
}</code></pre>
</div>
<div id="selectcenter" class="section level2">
<h2>selectCenter</h2>
<p>Author: Elizabeth Wonnacott</p>
<p>This function provides a wrapper around myCenter allowing you to
center a specific list of variables from a data frame.</p>
<ul>
<li>x: data frame</li>
<li>listfname: a list of the variables to be centered
(e.g. list(variable1,variable2))</li>
</ul>
<p>The output is a copy of the data frame with a column (always a
numeric variable) added for each of the centered variables. These
columns are labelled with the column’s previous name, but with “.ct”
appended (e.g., “variable1” will become “variable1.ct”).</p>
<pre class="r"><code>selectCenter= function(x, listfname) 
{
  for (i in 1:length(listfname)) 
  {
    fname = as.character(listfname[i])
    x[paste(fname,&quot;.ct&quot;, sep=&quot;&quot;)] = myCenter(x[fname])
  }
  
  return(x)
}</code></pre>
</div>
<div id="stat_string" class="section level2">
<h2>stat_string</h2>
<p>This function takes summary output from <code>addBf_ranges3</code>
and the name of a coefficient from that summary and formats so that can
be reported as a string in the main text. Default is to round all stats
to 2pd, apart from p values which are rounded to 3dp (as per APA
format)). Beta, SE, z p, Bayes factor (with (0,H1) as a subscript, where
H1 is the predicted of H1) and Robustness regions are all reported.</p>
<p>Note that as this stands, if the ranges are strings
(e.g. <code>&gt;4.5</code>) they won’t be rounded</p>
<pre class="r"><code>stat_string &lt;- function(Bfrange,
                        coefficientName,
                        dpbeta = 2,
                        dpse = 2,
                        dpz = 2,
                        dpp = 3,
                        dpseH1 = 2,
                        dpB = 3,
                        dpRRmin = 2,
                        dpRRmax = 2)
{
  beta = subset(Bfrange, coefficient == coefficientName)$estimate
  se = subset(Bfrange, coefficient == coefficientName)$std.Error
  z = subset(Bfrange, coefficient == coefficientName)$z
  p = subset(Bfrange, coefficient == coefficientName)$p
  seH1 = subset(Bfrange, coefficient == coefficientName)$sdtheory
  B = subset(Bfrange, coefficient == coefficientName)$Bf
  RRmin = subset(Bfrange, coefficient == coefficientName)$RRmin
  RRmax = subset(Bfrange, coefficient == coefficientName)$RRmax
  
  
  pstring = if (p &lt; .001) {
    &quot;, _p_ &lt;.001&quot;
  } else {
    paste(&quot;, _p_ =&quot;, round(p, dpp))
  }
  
  if (B &gt; 1000) {
    B = signif(B, digits = dpB)
  }
  else {
    B = round(B, dpB)
  }
  outstring = paste(
    &quot;_&amp;beta;_ = &quot;,
    round(beta, dpbeta),
    &quot;, _SE_ = &quot;,
    round(se, dpse),
    &quot;, _z_ = &quot; ,
    round(z, dpz),
    pstring ,
    &quot;, _B_&quot;,
    &quot;~(0,&quot;,
    round(seH1, dpseH1),
    &quot;)~&quot;,
    &quot; = &quot;,
    signif(B, digits = dpB),
    &quot;, _RR_ = [&quot;,
    RRmin,
    &quot;,&quot;,
    RRmax,
    &quot;]&quot;,
    sep = &quot;&quot;
  )
  return(outstring)
}</code></pre>
</div>
<div id="stat_string2" class="section level2">
<h2>stat_string2</h2>
<p>This function is the same as stat_string except that z and p aren’t
reported</p>
<pre class="r"><code>stat_string2 &lt;- function(Bfrange,
                         coefficientName,
                         dpbeta = 2,
                         dpse = 2,
                         dpz = 2,
                         dpp = 3,
                         dpseH1 = 2,
                         dpB = 3,
                         dpRRmin = 2,
                         dpRRmax = 2)
{
  beta = subset(Bfrange, coefficient == coefficientName)$estimate
  se = subset(Bfrange, coefficient == coefficientName)$std.Error
  B = subset(Bfrange, coefficient == coefficientName)$Bf
  RRmin = subset(Bfrange, coefficient == coefficientName)$RRmin
  RRmax = subset(Bfrange, coefficient == coefficientName)$RRmax
  seH1 = subset(Bfrange, coefficient == coefficientName)$sdtheory
  
  
  
  if (B &gt; 1000) {
    B = signif(B, digits = dpB)
  }
  else {
    B = round(B, dpB)
  }
  outstring = paste(
    &quot;_&amp;beta;_ = &quot;,
    round(beta, dpbeta),
    &quot;, _B_&quot;,
    &quot;~(0,&quot;,
    round(seH1, dpseH1),
    &quot;)~&quot;,
    &quot; = &quot;,
    signif(B, digits = dpB),
    &quot;, _RR_ = [&quot;,
    RRmin,
    &quot;,&quot;,
    RRmax,
    &quot;]&quot;,
    sep = &quot;&quot;
  )
  return(outstring)
}</code></pre>
</div>
<div id="summaryse" class="section level2">
<h2>summarySE</h2>
<p>Author: <a
href="http://www.cookbook-r.com/Manipulating_data/Summarizing_data/">Cookbook
for R</a>.</p>
<p>It summarizes data, giving count, mean, standard deviation, standard
error of the mean, and confidence interval (default 95%).</p>
<ul>
<li><p>data: a data frame</p></li>
<li><p>measurevar: the name of a column that contains the variable to be
summarized</p></li>
<li><p>groupvars: a vector containing the names of the columns that
contain grouping variables</p></li>
<li><p>na.rm: a boolean that indicates whether to ignore NA’s</p></li>
<li><p>conf.interval: the percent range of the confidence interval
(default is 95%)</p></li>
</ul>
<pre class="r"><code>summarySE &lt;- function(data = NULL, measurevar, groupvars = NULL, na.rm = FALSE,
                     conf.interval = .95, .drop = TRUE) {
  require(plyr)
  
  # New version of length which can handle NA&#39;s: if na.rm==T, don&#39;t count them
  length2 &lt;- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group&#39;s data frame, return a vector with
  # N, mean, and sd
  datac &lt;- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the &quot;mean&quot; column    
  datac &lt;- plyr::rename(datac, c(&quot;mean&quot; = measurevar))
  
  datac$se &lt;- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult &lt;- qt(conf.interval / 2 + .5, datac$N - 1)
  datac$ci &lt;- datac$se * ciMult
  
  return(datac)
}</code></pre>
</div>
<div id="summarysewithin" class="section level2">
<h2>summarySEwithin</h2>
<p>Author: <a
href="http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper">Cookbook
for R</a>. dataset argument implemented by: Eva Viviani and improved by
Elizabeth Wonnacott</p>
<p>From that website:</p>
<p>Summarizes data, handling within-subjects variables by removing
inter-subject variability. It will still work if there are no
within-subjects variables. Gives count, un-normed mean, normed mean
(with same between-group mean), standard deviation, standard error of
the mean, and confidence interval. If there are within-subject
variables, calculate adjusted values using method from Morey (2008).</p>
<ul>
<li><p>data: a data frame</p></li>
<li><p>measurevar: the name of a column that contains the variable to be
summarized</p></li>
<li><p>betweenvars: a vector containing names of columns that are
between-subjects variables</p></li>
<li><p>withinvars: a vector containing names of columns that are
within-subjects variables</p></li>
<li><p>idvar: the name of a column that identifies each subject (or
matched subjects)</p></li>
<li><p>na.rm: a boolean that indicates whether to ignore NA’s</p></li>
<li><p>conf.interval: the percent range of the confidence interval
(default is 95%)</p></li>
<li><p>dataset: if NULL (default), will produce a new dataset. If this
is set to “old” it adds the confidence intervals and groupmean into the
original dataframe, rather than into a new one</p></li>
</ul>
<pre class="r"><code>summarySEwithin &lt;- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,
                            idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE, dataset = NULL) {
  
  # Ensure that the betweenvars and withinvars are factors
  factorvars &lt;- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                       FUN=is.factor, FUN.VALUE=logical(1))
  
  if (!all(factorvars)) {
    nonfactorvars &lt;- names(factorvars)[!factorvars]
    message(&quot;Automatically converting the following non-factors to factors: &quot;,
            paste(nonfactorvars, collapse = &quot;, &quot;))
    data[nonfactorvars] &lt;- lapply(data[nonfactorvars], factor)
  }
  
  # Get the means from the un-normed data
  datac &lt;- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                     na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Drop all the unused columns (these will be calculated with normed data)
  datac$sd &lt;- NULL
  datac$se &lt;- NULL
  datac$ci &lt;- NULL
  
  # Norm each subject&#39;s data
  ndata &lt;- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
  
  # This is the name of the new column
  measurevar_n &lt;- paste(measurevar, &quot;_norm&quot;, sep=&quot;&quot;)
  
  # Collapse the normed data - now we can treat between and within vars the same
  ndatac &lt;- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                      na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Apply correction from Morey (2008) to the standard error and confidence interval
  #  Get the product of the number of conditions of within-S variables
  nWithinGroups    &lt;- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                  FUN.VALUE=numeric(1)))
  correctionFactor &lt;- sqrt( nWithinGroups / (nWithinGroups-1) )
  
  # Apply the correction factor
  ndatac$sd &lt;- ndatac$sd * correctionFactor
  ndatac$se &lt;- ndatac$se * correctionFactor
  ndatac$ci &lt;- ndatac$ci * correctionFactor
  
  # Combine the un-normed means with the normed results
  merge(datac, ndatac) -&gt; data2
  
  if (!is.null(dataset)){ # if we want the info in the same dataset:
    colnames(data2)[colnames(data2)==measurevar] &lt;- &quot;groupmean&quot;
    out = merge(data,data2)
    return(out)
    
  } else { # we want a new dataset
    return(data2)
  }
  
}</code></pre>
</div>
<div id="summarysewithin2" class="section level2">
<h2>summarySEwithin2</h2>
<p>This function is a wrapper around summarySEwithin2, from <a
href="http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper"
class="uri">http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper</a>
above It takes a dataframe and uses <code>summarySEwithin2</code> to get
the group means and variances for conditions and merges these into the
original dataframe</p>
<pre class="r"><code>summarySEwithin2 &lt;- function(data = NULL,
                             measurevar,
                             betweenvars = NULL,
                             withinvars = NULL,
                             idvar = NULL,
                             na.rm = FALSE,
                             conf.interval = .95,
                             .drop = TRUE) {
  data2 = summarySEwithin(
    data = data,
    measurevar = measurevar,
    betweenvars = betweenvars,
    withinvars = withinvars,
    idvar = idvar,
    na.rm = na.rm,
    conf.interval = conf.interval,
    .drop = .drop
  )
  colnames(data2)[colnames(data2) == measurevar] &lt;- &quot;groupmean&quot;
  out = merge(data, data2)
  return(out)
}</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
